uio - 输入/输出流
==================================

这个模块实现了相应 CPython 模块的一个子集，如下所述。有关更多信息，请参阅原始CPython文档: [io](https://docs.python.org/zh-cn/3/library/io.html#module-io)

此模块包含其他类型的stream（类文件）对象和帮助程序函数。

概念层次
--------------------

> 与CPython的区别
> 如本节所述，MicroPython中简化了流基类的概念层次结构。

正如在本部分中所述，流基类的概念层次结构在MicroPython中简化。

（摘要）基流类作为所有具体类行为的基础，在CPython中保持较少的二排序（两两排序法）。在MicroPython中，基流类被简化并隐藏以提高效率和节省资源。

CPython中一个重要的二分法是无缓冲对缓冲流。在MicroPython 中，所有流目前都未缓冲。这是因为所有现代操作系统， 甚至许多实时操作系统和文件系统驱动程序都已在侧面执行了缓冲。添加另一缓冲层会产生相反效果（称为“缓冲过满”的问题）， 且需占用宝贵的内存。注意：在某些情况下，缓冲可能有用，因此我们会在后面介绍一些可供选择的缓冲支持。

但是在CPython中，另一个重要二分法是与“缓冲性”联系在一起的，即流是否会引发短读/短写。短读即当用户从流中请求10个字节时， 但是所得少于该数量，短写与之相似。在CPython中，未缓冲流会自动进行短操作，而缓冲是对其的保证。非短读/写是一个重要特性， 由此我们得以开发更简洁高效的程序—非常适合MicroPython的程序。因此，尽管MicroPython不支持缓冲流，但仍适合非短操作流。 是否有短操作取决于每个特定类的需求，但是出于上述原因，强烈建议开发人员支持非短操作的行为。例如： MicroPython套接字就确保避免短 读/写。实际上，此时在核心中并无短操作流类的示例，一例是特定于端口的类，在这种情况下需由硬件特性来控制需求。

非短操作行为在非阻塞流情况会很棘手，阻塞对非阻塞的行为为CPython的另一种二分法，并受MicroPython完全支持。 非阻塞流不会等待数据到达或写入—而会读取/写入任何可能的数据或标记数据的缺乏（或写入数据的能力）。显而易见， 这与“非短操作”的方法相矛盾。的确，在CPython中，非阻塞缓冲流的情况非常复杂。在某些地方，这种结合是被禁止的； 在某些地方，未给出明定义或没有文档说明；在某些情况下。会引发较为复杂的异常。在MicroPython中，情况就简单多了： 非阻塞流对高效的异步操作至关重要，因此这一特性在“非短期操作”中占优先地位。所以，阻塞流会在任何情况下都尽可能避免短读/短写 （短读仅在到达文件末尾或发产生误差时出现（但是误差不会返回短数据，而会引发异常）），非阻塞流会产生短数据以避免阻碍操作。

最后一种二分法是二进制vs文本流。MicroPython支持这两种形式，但是在CPython中，文本流本质上就是缓冲的，它们并不在MicroPython中。（实际上，这就是我们引入缓冲支持的情况之一。）

注意：为提高效率，MicroPython不提供与以上层次结构相对应的抽象基类，并且不可能实现纯Python中的流类或将之归入子类。

函数
---------

```python
uio.open(name, mode='r', **kwargs)
```
   打开一个文件。内置open()函数是此函数的别名。

类
-------

```python
class FileIO(...)
```
这是以二进制模式打开的文件类型，例如使用 ``open(name, "rb")`` 
您不应该直接实例化这个类。

```python
class TextIOWrapper(...)
```
这是在文本模式下打开的文件类型，例如使用 ``open(name, "rt")`` 。
您不应该直接实例化这个类。

```python
class StringIO([string])
```
```python
class BytesIO([string])
```

用于输入/输出的内存文件类对象。 ``StringIO`` 用于文本模式I / O（类似于使用“t”修饰符打开的普通文件）。``BytesIO`` 用于二进制模式I ​​/ O（类似于使用“b”修饰符打开的普通文件）。可以使用字符串参数指定类文件对象的初始内容（应为普通字符串StringIO或字节对象BytesIO）。
所有常见的文件的方法，如 ``read()`` ， ``write()`` ， ``seek()`` ， ``flush()`` ， ``close()``  在这些对象上可用以下的方法:

```python
getvalue()
```
获取保存数据的底层缓冲区的当前内容。
